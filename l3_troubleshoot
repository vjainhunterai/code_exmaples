import pandas as pd
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError
import time
import os

start_time=time.time()
trigger_by=os.getlogin()
Job_Name="L3_Load"
Flow_Type="Direct"

print("start_time: ",start_time)
print("trigger_by: ",trigger_by)
print("Job_Name: ",Job_Name)
print("Flow_Type",Flow_Type)


def create_connection():
    """
    Establishes a connection to the MySQL database using SQLAlchemy and returns a session and engine.

    Returns:
        session (sqlalchemy.orm.session.Session): A session bound to the database engine.
        engine (sqlalchemy.engine.Engine): The engine object representing the database connection.
    """
    try:
        engine = create_engine(
            'mysql+mysqlconnector://test:Gpohealth!#!@dev-db-test.c969yoyq9cyy.us-east-1.rds.amazonaws.com/stg_tbl')
        Session = sessionmaker(bind=engine)
        print("Database connection established.")
        return Session(), engine
    except SQLAlchemyError as e:
        print(f"Error creating database connection: {e}")
        raise


def read_metadata(l3MetadataTable, l3metadb, engine):
    """
    Reads metadata from the specified table in the database and returns it as a dictionary.

    Args:
        l3MetadataTable (str): The name of the metadata table.
        l3metadb (str): The name of the database containing the metadata table.
        engine (sqlalchemy.engine.Engine): The database engine.

    Returns:
        dict: A dictionary where the keys are from the 'key' column and the values are from the 'value' column.
    """
    try:
        l3_metaquery = f"SELECT * FROM {l3metadb}.{l3MetadataTable}"
        df_metadata = pd.read_sql_query(l3_metaquery, engine)
        print("Metadata successfully retrieved from the database.")
        return df_metadata.set_index('key')['value'].to_dict()
    except SQLAlchemyError as e:
        print(f"Error reading metadata: {e}")
        raise


def fetch_all_sql_queries(session, query_meta_table, ctxArea):
    """
    Fetches all SQL queries from the metadata table, ordered by sequence number.

    Args:
        session (sqlalchemy.orm.session.Session): The session to execute the query.
        query_meta_table (str): The name of the query metadata table.
        ctxArea (str): The context area to filter the queries.

    Returns:
        list: A list of SQL queries ordered by the context key.
    """
    try:
        result = session.execute(
            text(f"SELECT ctxval,remarks FROM {query_meta_table} WHERE ctxarea='{ctxArea}' ORDER BY ctxkey"))
        print("SQL queries successfully fetched from the metadata table.")
        return result.fetchall()
    except SQLAlchemyError as e:
        print(f"Error fetching SQL queries: {e}")
        raise


def read_l2_audit_table(l2AuditTable, l2dbname, engine):
    """
    Reads distinct customer names and load dates from the L1 Invoice table.

    Args:
        l2InvTable (str): The name of the L1 Invoice table.
        l2dbname (str): The name of the database containing the L1 Invoice table.
        engine (sqlalchemy.engine.Engine): The database engine.

    Returns:
        pd.DataFrame: A DataFrame containing distinct customer names and load dates.
    """
    try:
        query = f"select  upper(Customer_Name) as Customer_Name,cast(L2_load_date as date) as L2_load_date from {l2dbname}.{l2AuditTable} group by upper(Customer_Name),L1_load_date,cast(L2_load_date as date)"
        df = pd.read_sql_query(query, engine)
        print("L2 Audit table data successfully retrieved.")
        print(df)
        return df
    except SQLAlchemyError as e:
        print(f"Error reading L2 Invoice table: {e}")
        raise


def read_l3_audit_table(l3AuditTable, l3dbname, engine):
    """
    Reads distinct customer names and load dates from the L2 Audit table.

    Args:
        l3AuditTable (str): The name of the L2 Audit table.
        l3dbname (str): The name of the database containing the L2 Audit table.
        engine (sqlalchemy.engine.Engine): The database engine.

    Returns:
        pd.DataFrame: A DataFrame containing distinct customer names and load dates.
    """
    try:
        query = f"select upper(Customer_Name) as Customer_Name,cast(L2_load_date as date) as L2_load_date from {l3dbname}.{l3AuditTable} group by upper(Customer_Name),cast(L2_load_date as date)"
        df = pd.read_sql_query(query, engine)
        print("L3 Audit table data successfully retrieved.")
        return df
    except SQLAlchemyError as e:
        print(f"Error reading L3 Audit table: {e}")
        raise


def delta_cust_details(df1, df2):
    """
    Calculates the delta (difference) between two DataFrames based on customer names and load dates.

    Args:
        df1 (pd.DataFrame): The first DataFrame containing customer names and load dates.
        df2 (pd.DataFrame): The second DataFrame containing customer names and load dates.

    Returns:
        pd.DataFrame: A DataFrame containing rows present in df1 but not in df2.
    """
    try:
        merge_df = df1.merge(df2, on=['Customer_Name', 'L2_load_date'], how='left', indicator=True)
        delta_df = merge_df[merge_df['_merge'] == 'left_only'].drop(columns=['_merge'])
        print("Delta between L2 and L3 data successfully calculated.")
        return delta_df
    except Exception as e:
        print(f"Error calculating delta: {e}")
        raise


def execute_sql(session, sql_query, variables=None):
    """
    Executes a given SQL query using the provided session, with optional variables for substitution.

    Args:
        session (sqlalchemy.orm.session.Session): The session to execute the query.
        sql_query (str): The SQL query to execute.
        variables (dict, optional): A dictionary of variables to substitute into the SQL query.
    """
    try:
        query = text(sql_query)
        #print("******** ",query,"******** ")
        session.execute(query, variables or {})
        session.commit()
        #print(f"Executed SQL query: {sql_query}")
        return 'SUCCESS', None
    except SQLAlchemyError as e:
        session.rollback()
        error_mesg = str(e)
        #print(f"Error executing SQL query: {e}")
        return 'FAIL', error_mesg

def l3Audit_cnt(srcDb,targetDb,srcTable,targetTable,Customer_Name,LoadDate,l3_dimdb,partty_group_table,engine):
    src_qury=f"select count(*) from {srcDb}.{srcTable} where invhdrNameCustomer='{Customer_Name}' and load_date='{LoadDate}'"
    print(src_qury)
    tsrc_cnt= pd.read_sql_query(src_qury,engine)
    src_cnt = tsrc_cnt.iloc[0, 0]
    party_query=f"select PARTY_GROUP_KEY from {l3_dimdb}.{partty_group_table} where PARTY_GROUP_NAME=upper('{Customer_Name}')"
    tparty_key=pd.read_sql_query(party_query,engine)
    partty_group_key=tparty_key.iloc[0,0]
    trgt_qury= f"select count(*) from {targetDb}.{targetTable} where PARTY_GROUP_KEY= {partty_group_key} and LOAD_DATE='{LoadDate}'"
    print(trgt_qury)
    ttrgt_cnt = pd.read_sql_query(trgt_qury,engine)
    trgt_cnt = ttrgt_cnt.iloc[0, 0]
    return src_cnt,trgt_cnt


def l3Execution():
    """
    Main execution function that coordinates reading metadata, fetching SQL queries, calculating deltas,
    and executing the queries for each set of variables.
    """
    try:
        # Create database session and engine
        session, engine = create_connection()

        # Reading parameters from the metadata table
        l3MetadataTable = "prod_context_l2_l3_python"
        meta_db_name = "stg_tbl"
        meta_l3_keys = read_metadata(l3MetadataTable, meta_db_name, engine)
        #print(meta_l2_keys)

        # Extract relevant parameters from the metadata
        srcTable = meta_l3_keys["L2_Inv_Table"]  # src table
        l2AuditTable = meta_l3_keys["L2_Audit_Table"]
        #L2_Server_Database = meta_l2_keys["L2_Server_Database"]  # src database
        l2_auditdb = meta_l3_keys["L2_Audit_Db"]
        l3AuditTable = meta_l3_keys["L3_Audit_Table"]
        L3_Audit_Db=meta_l3_keys["L3_Audit_Db"]
        srcDb= meta_l3_keys["L2_Server_Database"]
        targetDb= meta_l3_keys["L3_Server_Database"]
        targetTable= meta_l3_keys["L3_Inv_Table"]
        query_meta_table = meta_l3_keys["L3_Query_Metadata"]
        ctxArea = meta_l3_keys["L3_ctxarea"]
        l3_dimdb=meta_l3_keys["dim_db"]
        partty_group_table=meta_l3_keys["Dim_Party_Table"]
        #srcDb, targetDb, srcTable, targetTable, Customer_Name, LoadDate

        # Fetch all SQL queries in the correct order
        sql_queries = fetch_all_sql_queries(session, query_meta_table, ctxArea)
        #print(f"Fetched SQL Queries: {sql_queries}")

        # Read data from L1 Invoice and L2 Audit tables
        df1 = read_l2_audit_table(l2AuditTable, l2_auditdb, engine)
        #print(df1)
        df2 = read_l3_audit_table(l3AuditTable, L3_Audit_Db, engine)

        # Calculate the delta between L1 and L2 data
        df_delta = delta_cust_details(df1, df2)
        print(df_delta)

        # For each set of variables in the delta DataFrame, execute the SQL queries
        for index, row in df_delta.iterrows():
            variables = {
                "context_customer": row['Customer_Name'],
                "context_l2_date": row['L2_load_date']
            }
            customer_name=variables['context_customer']
            L2_load_date = variables['context_l2_date']
            #print(f"Variables for execution: {variables}")+
            print("customer name:", customer_name)
            print("L2_load_date:", L2_load_date)

            # Execute each SQL query with the current variable set
            for sql_row in sql_queries:
                sql_query = sql_row[0]  # Extract the SQL query from the row
                operation_type= sql_row[1] # Extract operation type from row
                print(sql_query)
                print("Operation Type:",operation_type)
                # Determine which variables are needed by this query
                required_variables = {key: variables[key] for key in variables if f":{key}" in sql_query}
                print(f"Executing SQL with variables: {required_variables}")




                # Execute the SQL query
                execute_sql(session, sql_query, required_variables)
                session.commit()
                Source_Count, Target_count = l3Audit_cnt(srcDb, targetDb, srcTable, targetTable, customer_name,
                                                         L2_load_date, l3_dimdb, partty_group_table, engine)

                print("src cnt:", Source_Count)
                print("trgt cnt:", Target_count)

        # Close the session after execution
        session.close()
        print("Database session closed.")

    except Exception as e:
        #print(f"Error in main execution: {e}")
        raise


if __name__ == "__main__":
    l3Execution()



=================================




from datetime import datetime
from sqlalchemy import create_engine, Table, Column, Integer, String, MetaData, DateTime, Date, text
from sqlalchemy.orm import sessionmaker
import pandas as pd
from sqlalchemy.exc import SQLAlchemyError
import os
import time

class databaseHandler:
    def __init__(self, dbUrl):
        self.engine = create_engine(dbUrl)
        self.connection = self.engine.connect()
        self.metadata = MetaData()

        print("Creating tables if they do not exist...")

        # L2 Audit Table
        self.l2AuditTable = Table('l2_audit_data', self.metadata,
                                  Column('Job_ID', String(250)),
                                  Column('Job_Name', String(250)),
                                  Column('Customer_Name', String(500)),
                                  Column('Flow_Type', String(250)),
                                  Column('Operation_type', String(120)),
                                  Column('Source_Count', Integer),
                                  Column('Target_count', Integer),
                                  Column('New_rcrd_count', Integer),
                                  Column('update_rcrd_count', Integer),
                                  Column('Start_Time', DateTime),
                                  Column('End_Time', DateTime),
                                  Column('Status', String(250)),
                                  Column('Insert_By', String(250)),
                                  Column('Error_desc', String(500)),
                                  Column('L1_load_date', Date),
                                  Column('L2_load_date', DateTime))

        self.metadata.create_all(self.engine)  # Create tables

        print("Initializing session...")
        Session = sessionmaker(bind=self.engine)
        self.session = Session()

    def insertL2AuditEntry(self, l2AuditEntry):
        try:
            print(f"Inserting L2 audit entry: {l2AuditEntry}")
            ins = self.l2AuditTable.insert().values(l2AuditEntry)
            self.session.execute(ins)
            self.session.commit()
            print("L2 audit entry committed.")
        except Exception as e:
            print(f"Error inserting L2 audit record: {e}")
            self.session.rollback()

    def close(self):
        print("Closing the session and connection...")
        self.session.close()
        self.connection.close()


# Integration of l2Execution with databaseHandler
def create_connection(dbUrl):
    """
    Reusing the databaseHandler class for connection handling.
    """
    try:
        db_handler = databaseHandler(dbUrl)
        print("Database connection established.")
        return db_handler
    except SQLAlchemyError as e:
        print(f"Error creating database connection: {e}")
        raise

def read_metadata(l2MetadataTable, l2metadb, engine):
    try:
        l2_metaquery = f"SELECT * FROM {l2metadb}.{l2MetadataTable}"
        df_metadata = pd.read_sql_query(l2_metaquery, engine)
        print("Metadata successfully retrieved from the database.")
        return df_metadata.set_index('key')['value'].to_dict()
    except SQLAlchemyError as e:
        print(f"Error reading metadata: {e}")
        raise

def fetch_all_sql_queries(session, query_meta_table, ctxArea):
    try:
        result = session.execute(
            text(f"SELECT ctxval,remarks FROM {query_meta_table} WHERE ctxarea='{ctxArea}' ORDER BY ctxkey"))
        print("SQL queries successfully fetched from the metadata table.")
        return result.fetchall()
    except SQLAlchemyError as e:
        print(f"Error fetching SQL queries: {e}")
        raise

def read_l1_inv_table(l1InvTable, l1dbname, engine):
    try:
        query = f"SELECT DISTINCT invhdrNameCustomer AS Customer_Name, load_date AS L1_load_date FROM {l1dbname}.{l1InvTable} "
        df = pd.read_sql_query(query, engine)
        print("L1 Invoice table data successfully retrieved.")
        return df
    except SQLAlchemyError as e:
        print(f"Error reading L1 Invoice table: {e}")
        raise

def read_l2_audit_table(l2AuditTable, l2dbname, engine):
    try:
        query = f"SELECT DISTINCT Customer_Name, L1_load_date FROM {l2dbname}.{l2AuditTable}"
        df = pd.read_sql_query(query, engine)
        print("L2 Audit table data successfully retrieved.")
        return df
    except SQLAlchemyError as e:
        print(f"Error reading L2 Audit table: {e}")
        raise

def delta_cust_details(df1, df2):
    try:
        merge_df = df1.merge(df2, on=['Customer_Name', 'L1_load_date'], how='left', indicator=True)
        delta_df = merge_df[merge_df['_merge'] == 'left_only'].drop(columns=['_merge'])
        print("Delta between L1 and L2 data successfully calculated.")
        return delta_df
    except Exception as e:
        print(f"Error calculating delta: {e}")
        raise

def l2Audit_cnt(srcDb, targetDb, srcTable, targetTable, Customer_Name, LoadDate, engine):
    src_qury = f"SELECT count(*) FROM {srcDb}.{srcTable} WHERE invhdrNameCustomer='{Customer_Name}' and load_date='{LoadDate}'"
    tsrc_cnt = pd.read_sql_query(src_qury, engine)
    src_cnt = tsrc_cnt.iloc[0, 0]
    trgt_qury = f"SELECT count(*) FROM {targetDb}.{targetTable} WHERE invhdrNameCustomer='{Customer_Name}' and load_date='{LoadDate}'"
    ttrgt_cnt = pd.read_sql_query(trgt_qury, engine)
    trgt_cnt = ttrgt_cnt.iloc[0, 0]
    return src_cnt, trgt_cnt

def execute_sql(session, sql_query, variables=None):
    try:
        query = text(sql_query)
        session.execute(query, variables or {})
        session.commit()
        return 'SUCCESS', None
    except SQLAlchemyError as e:
        session.rollback()
        error_mesg = str(e)
        return 'FAIL', error_mesg

def l2Execution():
    """
    Main execution function that integrates the database handler and SQL operations.
    """
    try:
        # Create database session using the handler
        dbUrl = 'mysql+mysqlconnector://test:Gpohealth!#!@dev-db-test.c969yoyq9cyy.us-east-1.rds.amazonaws.com/stg_tbl'
        db_handler = create_connection(dbUrl)

        # Reading metadata and other parameters
        l2MetadataTable = "prod_context_l2_l3_python"
        meta_db_name = "stg_tbl"
        meta_l2_keys = read_metadata(l2MetadataTable, meta_db_name, db_handler.engine)

        l1InvTable = meta_l2_keys["L1_Inv_Table"]
        l2AuditTable = meta_l2_keys["L2_Audit_Table"]
        l1db_name = meta_l2_keys["L1_server_DB"]
        l2_auditdb = meta_l2_keys["L2_Audit_Db"]
        srcDb = meta_l2_keys["L1_server_DB"]
        targetDb = meta_l2_keys["L2_Server_Database"]
        targetTable = meta_l2_keys["L2_Inv_Table"]
        query_meta_table = meta_l2_keys["L2_Query_Metadata"]
        ctxArea = meta_l2_keys["L2_ctxarea"]

        # Fetch all SQL queries
        sql_queries = fetch_all_sql_queries(db_handler.session, query_meta_table, ctxArea)

        # Read data from L1 Invoice and L2 Audit tables
        df1 = read_l1_inv_table(l1InvTable, l1db_name, db_handler.engine)
        df2 = read_l2_audit_table(l2AuditTable, l2_auditdb, db_handler.engine)

        # Calculate delta
        df_delta = delta_cust_details(df1, df2)
        print(df_delta)

        # For each set of variables in delta, execute the SQL queries
        for index, row in df_delta.iterrows():
            variables = {
                "context_customer": row['Customer_Name'],
                "context_l1_date": row['L1_load_date']
            }
            customer_name = variables['context_customer']
            L1_load_date = variables['context_l1_date']



            # Execute each SQL query
            for sql_row in sql_queries:
                sql_query = sql_row[0]  # SQL query
                execute_sql(db_handler.session, sql_query, variables)

                # Get source and target counts
                Source_Count, Target_count = l2Audit_cnt(srcDb, targetDb, l1InvTable, targetTable, customer_name,
                                                         L1_load_date, db_handler.engine)

                # Insert L2 audit entry after each query execution
                audit_entry = {
                    'Job_ID': "1234",  # Example, can be dynamic
                    'Job_Name': "L2_Load",
                    'Customer_Name': customer_name,
                    'Flow_Type': "Direct",
                    'Operation_type': "L2_Audit",
                    'Source_Count': int(Source_Count),
                    'Target_count': int(Target_count),
                    'New_rcrd_count': 0,  # Example, this can be dynamic based on query result
                    'update_rcrd_count': 0,  # Example, this can be dynamic based on query result
                    'Start_Time': datetime.now(),
                    'End_Time': datetime.now(),
                    'Status': "SUCCESS",
                    'Insert_By': os.getlogin(),
                    'Error_desc': "",
                    'L1_load_date': L1_load_date,
                    'L2_load_date': datetime.now()
                }
                db_handler.insertL2AuditEntry(audit_entry)

        # Close the database connection after execution
        db_handler.close()

    except Exception as e:
        print(f"Error in main execution: {e}")
        raise


if __name__ == "__main__":
    l2Execution()
